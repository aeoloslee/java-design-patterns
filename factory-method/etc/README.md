3.3 FACTORY METHOD（工厂方法）—对象创建型模式

1. 意图
定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使一个类的 实例化延迟到其子类。

2. 别名
虚构造器（Virtual Constructor）

3. 动机
框架使用抽象类定义和维护对象之间的关系。这些对象的创建通常也由框架负责。
考虑这样一个应用框架，它可以向用户显示多个文档。在这个框架中，两个主要的抽象是 类Application和Document。
这两个类都是抽象的，客户必须通过它们的子类来做与具体应用相 关的实现。例如，为创建一个绘图应用，
我们定义类 DrawingApplication和DrawingDocument。 Application类负责管理Document
并根据需要创建它们 — 例如，当用户从菜单中选择Open或New的时候。
因为被实例化的特定Document子类是与特定应用相关的，所以Application类不可能预测
到哪个Document子类将被实例化 — Application类仅知道一个新的文档何时应被创建，
而不知道哪一种Document将被创建。 这就产生了一个尴尬的局面：框架必须实例化类，
但是它只知道不能被实例化的抽象类。

Factory Method模式提供了一个解决办案。它封装了哪一个Document子类将被创建的信息并将这些信息从该框架中分离出来，
Application的子类重定义Application的抽象操作CreateDocument以返回适当的Document子类对象。
一旦一个Application子类实例化以后，它就可以实例化与应用相关的文档， 而无
需知道这些文档的类。我们称CreateDocument是一个工厂方法（factorymethod），因为它负责“生产”一个对象。

4. 适用性
在下列情况下可以使用Factory Method模式：
• 当一个类不知道它所必须创建的对象的类的时候。
• 当一个类希望由它的子类来指定它所创建的对象的时候。
• 当类将创建对象的职责委托给多个帮助子类中的某一个， 并且你希望将哪一个帮助子类
 是代理者这一信息局部化的时候。

 6. 参与者
 • Product(Document)
  — 定义工厂方法所创建的对象的接口。
 • ConcreteProduct（MyDocument）
  — 实现Product接口。
 • Creator（Application）
  — 声明工厂方法，该方法返回一个Product类型的对象。Creator也可以定义一个工厂方
  法的缺省实现，它返回一个缺省的ConcreteProduct对象。
  — 可以调用工厂方法以创建一个 Product对象。
 • ConcreteCreator（MyApplication）
  — 重定义工厂方法以返回一个 ConcreteProduct实例。
 • Creator依赖于它的子类来定义工厂方法，所以它返回一个适当的 ConcreteProduct实例。

 7. 协作
 • Creator依赖于它的子类来定义工厂方法，所以它返回一个适当的 ConcreteProduct实例。

 8. 效果

  工厂方法不再将与特定应用有关的类绑定到你的代码中。代码仅处理Product接口；因此 它可以与用户定义的任何ConcreteProduct类一起使用。
  工厂方法的一个潜在缺点在于客户可能仅仅为了创建一个特定的ConcreteProduct对象， 就不得不创建C r e a t o r的子类。当C r e a t o r子类不必需时， 客户现在必然要处理类演化的其他方 面；但是当客户无论如何必须创建 Creator的子类时，创建子类也是可行的。
 下面是Factory Method模式的另外两种效果：
  1 ) 为子类提供挂钩（ h o o k） 用工厂方法在一个类的内部创建对象通常比直接创建对象 更灵活。 Factory Method给子类一个挂钩以提供对象的扩展版本。
  在Document的例子中， Document类可以定义一个称为 CreateFileDialog的工厂方法，该方 法为打开一个已有的文档创建默认的文件对话框对象。 D o c u m e n t的子类可以重定义这个工厂 方法以定义一个与特定应用相关的文件对话框。 在这种情况下， 工厂方法就不再抽象了而是 提供了一个合理的缺省实现。
  2) 连接平行的类层次 迄今为止， 在我们所考虑的例子中， 工厂方法并不往往只是被 Creator调用，客户可以找到一些有用的工厂方法，尤其在平行类层次的情况下。
  当一个类将它的一些职责委托给一个独立的类的时候， 就产生了平行类层次。 考虑可以 被交互操纵的图形；也就是说， 它们可以用鼠标进行伸展、移动， 或者旋转。 实现这样一些 交互并不总是那么容易， 它通常需要存储和更新在给定时刻记录操纵状态的信息， 这个状态 仅仅在操纵时需要。 因此它不需要被保存在图形对象中。 此外， 当用户操纵图形时， 不同的 图形有不同的行为。 例如， 将直线图形拉长可能会产生一个端点被移动的效果， 而伸展正文 图形则可能会改变行距。

 9. 实 现
 当应用Factory Method模式时要考虑下面一些问题：
 1 ) 主要有两种不同的情况 Factory Method模式主要有两种不同的情况： 1）第一种情况 是， C r e a t o r类是一个抽象类并且不提供它所声明的工厂方法的实现。 2）第二种情况是， C r e a t o r是一个具体的类而且为工厂方法提供一个缺省的实现。 也有可能有一个定义了缺省实 现的抽象类，但这不太常见。
 第一种情况需要子类来定义实现， 因为没有合理的缺省实现。 它避免了不得不实例化不 可预见类的问题。在第二种情况中，具体的 C r e a t o r主要因为灵活性才使用工厂方法。 它所遵 循的准则是，“用一个独立的操作创建对象， 这样子类才能重定义它们的创建方式。”这条准 则保证了子类的设计者能够在必要的时候改变父类所实例化的对象的类。
 2 ) 参数化工厂方法 该模式的另一种情况使得工厂方法可以创建多种产品。 工厂方法采 用一个标识要被创建的对象种类的参数。 工厂方法创建的所有对象将共享 P r o d u c t接口。在 D o c u m e n t的例子中， A p p l i c a t i o n可能支持不同种类的 D o c u m e n t。你给C r e a t e D o c u m e n t传递一 个外部参数来指定将要创建的文档的种类。
 图形编辑框架Unidraw [VL90]使用这种方法来重构存储在磁盘上的对象。 Unidraw定义了 一个C r e a t o r类，该类拥有一个以类标识符为参数的工厂方法 C r e a t e。 类标识符指定要被实例 化的类。当Unidraw将一个对象存盘时，它首先写类标识符，然后是它的实例变量。当它从磁 盘中重构该对象时，它首先读取的是类标识符。
 一旦类标识符被读取后，这个框架就将该标识符作为参数，调用 C r e a t e。C r e a t e到构造器 中查询相应的类并用它实例化对象。最后， C r e a t e调用对象的 R e a d操作， 读取磁盘上剩余的 信息并初始化该对象的实例变量。
 一个参数化的工厂方法具有如下的一般形式，此处 M y P r o d u c t和Yo u r P r o d u c t是P r o d u c t的 子类：