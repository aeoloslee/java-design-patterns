4.4 DECORATOR（装饰）—对象结构型模式

1. 意图
动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活（因为它实际采用聚合的方式）。

2. 别名 包装器Wrapper

3. 动机
有时我们希望给某个对象而不是整个类添加一些功能。 例如，一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些特性，
例如边框，或是一些行为，例如窗口滚动。使用继承机制是添加功能的一种有效途径， 从其他类继承过来的边框特性可以被多个子类
的实例所使用。 但这种方法不够灵活， 因为边框的选择是静态的， 用户不能控制对组件加边框的方式和时机。

一种较为灵活的方式是将组件嵌入另一个对象中， 由这个对象添加边框。 我们称这个嵌入的对象为装饰。
这个装饰与它所装饰的组件接口一致， 因此它对使用该组件的客户透明。 它将客户请求转发给该组件，
并且可能在转发前后执行一些额外的动作（例如画一个边框）。 透明性使得你可以递归的嵌套多个装饰，
从而可以添加任意多的功能，如下图所示。

例如，假定有一个对象TextView，它可以在窗口中显示正文。缺省的TextView没有滚动 条，
因为我们可能有时并不需要滚动条。当需要滚动条时，我们可以用ScrollDecorator添加滚 动条。
如果我们还想在TextView周围添加一个粗黑边框，可以使用BorderDecorator添加。
因 此只要简单地将这些装饰和 TextView进行组合，就可以达到预期的效果。

一个通用功能接口(基础)：基础实现类和装饰器类都必须实现该接口。

实现：基本功能的类TextView
实现：很多装饰器类(提供附加功能)ScrollDecorator、BorderDecorator【还可以抽象出一个高层的装饰器接口Decorator】


Decorator的子类为特定功能可以自由地添加一些操作。 例如， 如果其他对象知道界面中 恰好有一个ScrollDecorator对象，
这些对象就可以用 ScrollDecorator对象的ScrollTo操作滚动这 个界面。这个模式中有一点很重要，
它使得在 Vi s u a l C o m p o n e n t可以出现的任何地方都可以有 装饰。 因此， 客户通常不会感觉到装饰过的组件
与未装饰组件之间的差异， 也不会与装饰产 生任何依赖关系。

4. 适用性以下情况使用Decorator模式
• 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
• 处理那些可以撤消的职责。
• 当不能采用生成子类的方法进行扩充时。 一种情况是， 可能有大量独立的扩展， 为支持
 每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类
 定义被隐藏，或类定义不能用于生成子类。

 6. 参与者
 • Component (VisualComponent)
  — 定义一个对象接口，可以给这些对象动态地添加职责。
 • ConcreteComponent (TextView)
  — 定义一个对象，可以给这个对象添加一些职责。
 • Decorator
  — 维持一个指向Component对象的指针，并定义一个与 Component接口一致的接口。
 • ConcreteDecorator (BorderDecorator, ScrollDecorator)
  — 向组件添加职责。

  7. 协作
  • Decorator将请求转发给它的Component对象，并有可能在转发请求前后执行一些附加的动作。

  8. 效果 Decorator模式至少有两个主要优点和两个缺点：
   1) 比静态继承更灵活 与对象的静态继承（多重继承）相比， Decorator模式提供了更加灵活的向对象添加职责的方式。
    可以用添加和分离的方法， 用装饰在运行时刻增加和删除职责。相比之下，继承机制要求为每个添加的职责创建一个新的子类
    （例如， BorderScrollableTextView, BorderedTextView）。这会产生许多新的类，
    并且会增加系统的复杂度。此外，为一 个特定的C o m p o n e n t类提供多个不同的 De c o r a t o r类，
     这就使得你可以对一些职责进行混合和匹配。

   使用Decorator模式可以很容易地重复添加一个特性，例如在TextView上添加双边框时，
   仅需将添加两个BorderDecorator即可。而两次继承Border类则极容易出错的。
    2) 避免在层次结构高层的类有太多的特征 D e c o r a t o r模式提供了一种“即用即付”的方 法来添加职责。
    它并不试图在一个复杂的可定制的类中支持所有可预见的特征， 相反， 你可 以定义一个简单的类，
    并且用 D e c o r a t o r类给它逐渐地添加功能。 可以从简单的部件组合出复 杂的功能。这样，
    应用程序不必为不需要的特征付出代价。同时也更易于不依赖于 D e c o r a t o r 所扩展（甚至是不可预知的扩展）
    的类而独立地定义新类型的 D e c o r a t o r。 扩展一个复杂类的 时候，很可能会暴露与添加的职责无关的细节。
    3) Decorator与它的C o m p o n e n t不一样 D e c o r a t o r是一个透明的包装。
     如果我们从对象标 识的观点出发， 一个被装饰了的组件与这个组件是有差别的， 因此， 使用装饰时不应该依赖 对象标识。
    4) 有许多小对象 采用Decorator模式进行系统设计往往会产生许多看上去类似的小对象，
    这些对象仅仅在他们相互连接的方式上有所不同， 而不是它们的类或是它们的属性值有所不 同。
    尽管对于那些了解这些系统的人来说， 很容易对它们进行定制， 但是很难学习这些系统， 排错也很困难。

    9. 实现 使用Decorator模式时应注意以下几点：
     1) 接口的一致性 装饰对象的接口必须与它所装饰的 Component的接口是一致的，因此，
     所有的ConcreteDecorator类必须有一个公共的父类（至少在 C++中如此）。