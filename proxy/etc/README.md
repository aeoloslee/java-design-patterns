4.7 PROXY（代理）—对象结构型模式

1. 意图 为其他对象提供一种代理以控制对这个对象的访问。

2. 别名 Surrogate

3. 动机
对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。我们考虑一个可以在
文档中嵌入图形对象的文档编辑器。 有些图形对象（如大型光栅图像）的创建开销很大。 但是打开文档必须很迅速，
因此我们在打开文档时应避免一次性创建所有开销很大的对象。 因为并非所有这些对象在文档中都同时可见， 所以也没有
必要同时创建这些对象。

这一限制条件意味着， 对于每一个开销很大的对象， 应该根据需要进行创建， 当一个图像变为可见时会产生这样的需要。
但是在文档中我们用什么来代替这个图像呢？我们又如何才能隐藏根据需要创建图像这一事实，从而不会使得编辑器的实现复杂化呢？
例如，这种优化不应影响绘制和格式化的代码。

问题的解决方案是使用另一个对象，即图像Proxy，替代那个真正的图像。Proxy可以代替一个图像对象，
并且在需要时负责实例化这个图像对象。

只有当文档编辑器激活图像代理的 Draw操作以显示这个图像的时候，图像 Proxy才创建真 正的图像。
P r o x y直接将随后的请求转发给这个图像对象。 因此在创建这个图像以后， 它必须 有一个指向这个图像的引用。
我们假设图像存储在一个独立的文件中。这样我们可以把文件名作为对实际对象的引用。
P r o x y还存储了图像的尺寸（e x t e n t），即它的长和宽。有了图像尺寸， P r o x y无须真正实例化
这个图像就可以响应格式化程序对图像尺寸的请求。

 4. 适用性
 在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用 P r o x y模式。下面是一 些可以使用Proxy模式常见情况：
 1) 远 程 代 理 （ Remote Proxy ） 为 一 个 对 象在 不 同 的 地 址 空间 提 供 局 部 代 表。
 NEXTSTEP[Add94] 使用N X P r o x y类实现了这一目的。 Coplien[Cop92] 称这种代理为“大使” （Ambassador）。
 2) 虚代理（Virtual Proxy）根据需要创建开销很大的对象。在动机一节描述的 ImageProxy
 就是这样一种代理的例子。
 3) 保护代理（Protection Proxy）控制对原始对象的访问。 保护代理用于对象应该有不同 的访问权限的时候。例如，
 在 C h o i c e s操作系统[ C I R M 9 3 ]中K e m e l P r o x i e s为操作系统对象提供 了访问保护。
 4) 智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。 它的典型用途包括：
    • 对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它 (也称为S m a r t
    Pointers[Ede92])。
    • 当第一次引用一个持久对象时，将它装入内存。
    • 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。


5.结构

6. 参与者
• Proxy (ImageProxy)
 — 保存一个引用使得代理可以访问实体。若 R e a l S u b j e c t和S u b j e c t的接口相同， P r o x y会
 引用Subject。
 — 提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。
 — 控制对实体的存取，并可能负责创建和删除它。
 — 其他功能依赖于代理的类型：
• Remote Pro x y负责对请求及其参数进行编码， 并向不同地址空间中的实体发送已编
 码的请求。
• Virtual Proxy可以缓存实体的附加信息，以便延迟对它的访问。例如，动机一节中提
 到的ImageProxy缓存了图像实体的尺寸。
• Protection Proxy检查调用者是否具有实现一个请求所必需的访问权限。
• Subject (Graphic)
 — 定义RealSubject 和Proxy的共用接口，这样就在任何使用 RealSubject的地方都可以使
 用Proxy。
• RealSubject (Image)
 — 定义Proxy所代表的实体。

7. 协作
• 代理根据其种类，在适当的时候向 RealSubject转发请求。

8. 效果
P r o x y模式在访问对象时引入了一定程度的间接性。 根据代理的类型， 附加的间接性有多 种用途：
1) Remote Proxy可以隐藏一个对象存在于不同地址空间的事实。
2) Virtual Proxy 可以进行最优化，例如根据要求创建对象。
3) Protection Proxies和Smart Reference都允许在访问一个对象时有一些附加的内务处理 （Housekeeping task）。
Proxy模式还可以对用户隐藏另一种称之为 c o p y - o n - w r i t e的优化方式，该优化与根据需要
创建对象有关。 拷贝一个庞大而复杂的对象是一种开销很大的操作， 如果这个拷贝根本没有
被修改， 那么这些开销就没有必要。 用代理延迟这一拷贝过程， 我们可以保证只有当这个对
象被修改的时候才对它进行拷贝。
在实现C o p y - o n - w r i t e时必须对实体进行引用计数。 拷贝代理仅会增加引用计数。 只有当
用户请求一个修改该实体的操作时， 代理才会真正的拷贝它。 在这种情况下， 代理还必须减
少实体的引用计数。当引用的数目为零时，这个实体将被删除。
Copy-on-Write可以大幅度的降低拷贝庞大实体时的开销。


9.分类

静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。
动态代理：在程序运行时，运用反射机制动态创建而成。

静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。
动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，
而是在运行时动态生成的类字节码，并加载到JVM中。

动态代理的作用：
人家是动态编程，需要在原来的方法的功能基础上再添加一些功能，而不用改变这个方法的签名，原来调用这个方法的类依然能正常工作。
比如，现在要把一段文本发送给另一个人，普通方法是 void send(File a)，现在我们弄出个特性，就像 Spring AOP 那样，
在 send 之前给这个 a 压缩一下。原来的程序没有压缩功能，现在我们需要添加的话而不改变原来所有的代码的话就得用类似
AOP 这样的代码来处理。
一般一个无法再继承的类和方法，要用代理，而能够继承的类和方法可以在内在中直接生成一个新的 java 类继承它然后覆盖掉那个
send 方法，像 hibernate/spring/jboss 都把这些自动完成了。
而像 AspectJ 这种 AOP 刚不同，它直接把人家的 class 代码修改了，它就不需要使用代理。
这些在新的 JDK 6 中都可以通过 Instrument 来做到，不过也是个通用的方法，还得通过规则来定制什么情况下处理，
什么时候不处理。