3.1 ABSTRACT FACTORY（抽象工厂）—对象创建型模式

1. 意 图
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
2. 别 名
 Kit
3. 动 机
考虑一个支持多种视感（ l o o k - a n d - f e e l）标准的用户界面工具包， 例如 M o t i f和
Presentation Manager。 不同的视感风格为诸如滚动条、窗口和按钮等用户界面“窗口组件” 定义不同的外观和行为。
为保证视感风格标准间的可移植性， 一个应用不应该为一个特定的 视感外观硬编码它的窗口组件。
在整个应用中实例化特定视感风格的窗口组件类将使得以后 很难改变视感风格。

4. 适用性
在以下情况可以使用Abstract Factory模式
• 一个系统要独立于它的产品的创建、组合和表示时。
• 一个系统要由多个产品系列中的一个来配置时。
• 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
• 当你提供一个产品类库，而只想显示它们的接口而不是实现时。

6. 参与者
• AbstractFactory (WidgetFactory) 也可以是接口类型
— 声明一个创建抽象产品对象的操作接口。
• ConcreteFactory (MotifWidgetFactory，PMWidgetFactory)
 — 实现创建具体产品对象的操作。
• AbstractProduct (Windows，ScrollBar)
 — 为一类产品对象声明一个接口。也可以是接口类型
• ConcreteProduct (MotifWindow，MotifScrollBar)
 — 定义一个将被相应的具体工厂创建的产品对象。
 — 实现AbstractProduct接口。
• Client
 — 仅使用由AbstractFactory和AbstractProduct类声明的接口。

 7. 协 作
 • 通常在运行时刻创建一个 ConcreteFactory类的实例。这一具体的工厂创建具有特定实现
  的产品对象。为创建不同的产品对象，客户应使用不同的具体工厂。
 • AbstractFactory将产品对象的创建延迟到它的 ConcreteFactory子类。


8. 效 果 AbstractFactory模式有下面的一些优点和缺点：

 1) 它分离了具体的类 Abstract Factory模式帮助你控制一个应用创建的对象的类。 因为一个工厂封装创建产品对象
 的责任和过程， 它将客户与类的实现分离。 客户通过它们的抽象 接口操纵实例。产品的类名也在具体工厂的实现中被分离；
 它们不出现在客户代码中。
 2) 它使得易于交换产品系列 一个具体工厂类在一个应用中仅出现一次 —即在它初始化 的时候。
 这使得改变一个应用的具体工厂变得很容易。 它只需改变具体的工厂即可使用不同 的产品配置，
 这是因为一个抽象工厂创建了一个完整的产品系列， 所以整个产品系列会立刻 改变。
 在我们的用户界面的例子中， 我们仅需转换到相应的工厂对象并重新创建接口，
 就可实现从Motif窗口组件转换为Presentation Manager窗口组件。
 3) 它有利于产品的一致性 当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，
 这一点很重要。而 AbstractFactory很容易实现这一点。
 4) 难以支持新种类的产品 难以扩展抽象工厂以生产新种类的产品。 这是因为AbstractFactory接口确定了可以被创建的产品集合。
 支持新种类的产品就需要扩展该工厂接口，这将涉及AbstractFactory类及其所有子类的改变。我们会在实现一节讨论这个问题的
 一个解决办法。

 9.实现

 定义可扩展的工厂

 AbstractFactory通常为每一种它可以生产的产品定义一个操作。产
 品的种类被编码在操作型构中。增加一种新的产品要求改变 AbstractFactory的接口以及所有与 它相关的类。
 一个更灵活但不太安全的设计是给创建对象的操作增加一个参数。 该参数指定
 了将被创建的对象的种类。 它可以是一个类标识符、一个整数、一个字符串， 或其他任何可以标识这种产品的东西。
 实际上使用这种方法， AbstractFactory只需要一个“ Make”操作和一个指示要创建对象的种类的参数。


